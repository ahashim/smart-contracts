// SPDX-License-Identifier: Apache-2.0
/*

   Copyright 2022 Critter

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

*/
pragma solidity ^0.8.4;

// Base Contracts
import '@openzeppelin/contracts-upgradeable/access/AccessControlEnumerableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol';
import '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721BurnableUpgradeable.sol';
import '@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol';

// Libraries
import './libraries/StringTheory.sol';

// Interfaces
import './interfaces/ICritter.sol';

/**
 * @dev Critter: a microblogging platform where each post is
 *      an {ERC721} token. Functionality includes:
 *
 *          - ability for holders to burn (destroy) their tokens
 *          - a minter role that allows for token minting (creation)
 *          - a pauser role that allows to stop all token transfers
 *          - an upgader role that allows an address to upgrade the contract
 *          - token ID and URI autogeneration
 *
 *      This contract uses {AccessControlEnumerable} to lock permissioned
 *      functions using the different roles - head to its documentation for
 *      details.
 */
contract Critter is
    Initializable,
    ERC721Upgradeable,
    ERC721EnumerableUpgradeable,
    ERC721URIStorageUpgradeable,
    PausableUpgradeable,
    AccessControlEnumerableUpgradeable,
    ERC721BurnableUpgradeable,
    UUPSUpgradeable,
    ICritter
{
    using CountersUpgradeable for CountersUpgradeable.Counter;

    // Roles
    bytes32 public constant MINTER_ROLE = keccak256('MINTER_ROLE');
    bytes32 public constant PAUSER_ROLE = keccak256('PAUSER_ROLE');
    bytes32 public constant UPGRADER_ROLE = keccak256('UPGRADER_ROLE');

    // A counter keeps track of token ID's instead of {balanceOf} due to burning
    CountersUpgradeable.Counter private _tokenIdCounter;

    string private _baseTokenURI;

    /**
     * @dev Mapping of tokenId's to Squeaks.
     *      See {ICritter-Squeak} for more info.
     */
    mapping(uint256 => Squeak) public squeaks;

    /**
     * @dev Mapping of usernames => account addresses.
     */
    mapping(string => address) public addresses;

    /**
     * @dev Mapping of account addresses => usernames.
     */
    mapping(address => string) public usernames;

    /**
     * @dev Ensures that `_address` has a Critter account.
     */
    modifier hasAccount(address _address) {
        require(
            bytes(usernames[_address]).length > 0,
            'Critter: address does not have an account'
        );
        _;
    }

    /**
     * @dev Ensures that `_address` does not have a Critter account.
     */
    modifier noAccount(address _address) {
        require(
            bytes(usernames[msg.sender]).length == 0,
            'Critter: account already exists'
        );
        _;
    }

    /**
     * @dev Ensures that `username` satisfies the following requirements:
     *
     *      - Greater than 0 bytes (cannot be empty).
     *      - Less than 32 bytes (upper bound for storage slot optimization).
     *      - Is not already in use.
     */
    modifier isValidUsername(string memory username) {
        require(
            bytes(username).length > 0,
            'Critter: username cannot be empty'
        );
        require(bytes(username).length <= 32, 'Critter: username is too long');
        require(addresses[username] == address(0), 'Critter: username taken');
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() initializer {}

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` `UPGRADER_ROLE`, and
     *      `PAUSER_ROLE` to the account that deploys the contract.
     *
     *      Token URIs will be autogenerated based on `baseTokenURI` and their
     *      token IDs.
     */
    function initialize(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) public initializer {
        // initialize base contracts
        __ERC721_init(name, symbol);
        __ERC721Enumerable_init();
        __ERC721URIStorage_init();
        __Pausable_init();
        __AccessControl_init();
        __ERC721Burnable_init();
        __UUPSUpgradeable_init();

        // set base token URI
        _baseTokenURI = baseTokenURI;

        // grant all roles to contract owner
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(MINTER_ROLE, msg.sender);
        _grantRole(PAUSER_ROLE, msg.sender);
        _grantRole(UPGRADER_ROLE, msg.sender);

        // set initial token ID to 1
        _tokenIdCounter.increment();
    }

    /**
     * @dev See {IERC165Upgradeable-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(
            ERC721Upgradeable,
            ERC721EnumerableUpgradeable,
            IERC165Upgradeable,
            AccessControlEnumerableUpgradeable
        )
        returns (bool)
    {
        return
            interfaceId == type(ICritter).interfaceId ||
            super.supportsInterface(interfaceId);
    }

    /**
     * @dev See {ICritter-createAccount}.
     */
    function createAccount(string memory username)
        public
        override(ICritter)
        noAccount(msg.sender)
        isValidUsername(username)
        returns (bool)
    {
        // set our address & username mappings
        addresses[username] = msg.sender;
        usernames[msg.sender] = username;

        // bypassing the admin-check to grant roles in order to
        // automatically initialize users when they create an account.
        _grantRole(MINTER_ROLE, msg.sender);

        // log account creation
        emit AccountCreated(msg.sender, username);

        return true;
    }

    /**
     * @dev See {ICritter-updateUsername}.
     */
    function updateUsername(string memory newUsername)
        public
        override(ICritter)
        hasAccount(msg.sender)
        isValidUsername(newUsername)
        returns (bool)
    {
        // clear current username from the addresses mapping
        string memory oldUsername = this.usernames(msg.sender);
        delete addresses[oldUsername];

        // set new usernames & address mappings
        addresses[newUsername] = msg.sender;
        usernames[msg.sender] = newUsername;

        // log the change
        emit UsernameUpdated(msg.sender, oldUsername, newUsername);

        return true;
    }

    /**
     * @dev See {ICritter-createSqueak}.
     */
    function createSqueak(string memory content)
        public
        override(ICritter)
        hasAccount(msg.sender)
        returns (bool)
    {
        // check invariants
        require(bytes(content).length > 0, 'Critter: squeak cannot be empty');
        require(bytes(content).length <= 256, 'Critter: squeak is too long');

        // get current tokenID & update counter
        uint256 tokenId = _tokenIdCounter.current();
        _tokenIdCounter.increment();

        // build squeak & save it to storage
        Squeak storage squeak = squeaks[tokenId];
        squeak.account = msg.sender;
        squeak.content = content;

        // mint our token
        safeMint(msg.sender, tokenId);

        // log the token ID & content
        emit SqueakCreated(msg.sender, tokenId, squeak.content);

        return true;
    }

    /**
     * @dev See {ICritter-deleteSqueak}.
     */
    function deleteSqueak(uint256 tokenId)
        public
        override(ICritter)
        hasAccount(msg.sender)
        returns (bool)
    {
        // burn ERC721 token
        burn(tokenId);

        // delete squeak from storage
        delete squeaks[tokenId];

        // log deleted token ID
        emit SqueakDeleted(msg.sender, tokenId);

        return true;
    }

    /**
     * @dev See {IERC721Upgradeable-_baseURI}.
     */
    function _baseURI()
        internal
        view
        override(ERC721Upgradeable)
        returns (string memory)
    {
        return _baseTokenURI;
    }

    /**
     * @dev See {IERC721MetadataUpgradeable-tokenURI}.
     */
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    /**
     * @dev See {ICritter-safeMint}.
     */
    function safeMint(address to, uint256 tokenId)
        public
        override(ICritter)
        onlyRole(MINTER_ROLE)
    {
        string memory tokenUri = _generateUri(tokenId);

        _safeMint(to, tokenId);
        _setTokenURI(tokenId, tokenUri);
    }

    /**
     * @dev See {ICritter-pause}.
     */
    function pause() public override(ICritter) onlyRole(PAUSER_ROLE) {
        _pause();
    }

    /**
     * @dev See {ICritter-unpause}.
     */
    function unpause() public override(ICritter) onlyRole(PAUSER_ROLE) {
        _unpause();
    }

    /**
     * @dev Function that should revert when `msg.sender` is not authorized to
     *      upgrade the contract.
     */
    function _authorizeUpgrade(address newImplementation)
        internal
        view
        onlyRole(UPGRADER_ROLE)
        override
    {}

    /**
     * @dev Burns `tokenId`. See {ERC721Upgradeable-_burn}.
     *
     *      Requirements:
     *
     *      - The caller must own `tokenId` or be an approved operator.
     */
    function _burn(uint256 tokenId)
        internal
        override(ERC721Upgradeable, ERC721URIStorageUpgradeable)
    {
        super._burn(tokenId);
    }

    /**
     * @dev Hook that is called before any token transfer. This includes minting
     *      and burning.
     *
     *      Calling conditions:
     *
     *      - When `from` and `to` are both non-zero, ``from``'s `tokenId` will
     *      be transferred to `to`.
     *      - When `from` is zero, `tokenId` will be minted for `to`.
     *      - When `to` is zero, ``from``'s `tokenId` will be burned.
     *      - `from` and `to` are never both zero.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721Upgradeable, ERC721EnumerableUpgradeable) whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev Generate token URI based on chain & token ID.
     */
    function _generateUri(uint256 tokenId)
        internal
        view
        returns (string memory)
    {
        // get the hash of the token based on its chain ID & token ID
        bytes32 hashedUri = keccak256(abi.encode(block.chainid, tokenId));

        return StringTheory.lower(StringTheory.toHexString(hashedUri));
    }
}
